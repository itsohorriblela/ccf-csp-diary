stl基础知识

vector 头文件#include<vector>
vector<T> 容器是包含 T 类型元素的序列容器，vector<T> 容器的大小可以自动增长，从而可以包含任意数量的元素；因此类型参数 T 不再需要模板参数 N。只要元素个
数超出 vector 当前容量，就会自动分配更多的空间。只能在容器尾部高效地删除或添加元素。vector<T> 容器可以方便、灵活地代替数组。在大多数时候，都可以用
vector<T> 代替数组存放元素。只要能够意识到，vector<T> 在扩展容量，以及在序列内部删除或添加元素时会产生一些开销；但大多数情况下，代码不会明显变慢。
完美解决了菜鸡王少奇每次想定义 int n;cin>>n;int a[n];的问题。

    //1.定义和初始化
    与stack初始化类似 
    vector<type> namestd::vector<double> values(20);    //默认初始化，初始值都为0
    std::vector<long> numbers(20, 99L); //将所有值都初始化为99L
    std::vector<unsigned int> primes {2u, 3u, 5u, 7u, 11u, 13u, 17u, 19u};//初始化列表
    vector<int> vec[100];    //每一个vec[i]是vector类型，vec[100]相当于一个二维数组。
    std::array<std :: string, 5> words {"one", "two","three", "four", "five"};
    std::vector<std::string> words_copy {std::begin(words) , std::end(words)};//用words来初始化words_copy
    
    //2.vector的容量与大小
    auto nElements = primes.size();//可用auto关键字方便保存大小和容量
    ![image](https://github.com/itsohorriblela/ccf-csp-diary/blob/master/images/valuesofvector.jpg)
    
    //3.常用方法
    values[0] = 3.14159;//像标准数组一样通过索引访问元素
    values.front() = 3.14159;
    values.back() = 2.71828;//成员函数 front() 和 back() 分別返回序列中第一个和最后一个元素的引用
    auto pData = values.data();//成员函数 data() 返回一个指向数组的指针，它在内部被用来存储元素。pData 是 type* 类型
    
    //2.常用操作方法
    vec1.push_back(100);            //添加元素
    int size = vec1.size();         //元素个数
    bool isEmpty = vec1.empty();    //判断是否为空
    cout<<vec1[0]<<endl;        //取得第一个元素
    vec1.insert(vec1.end(),5,3);    //从vec1.back位置插入个值为的元素
    //vec1.pop_back();              //删除末尾元素
    //vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移
    cout<<(vec1==vec2)?true:false;  //判断是否相等==、！=、>=、<=...
    //vec1.clear();                 //清空元素
    
    //3.遍历
       int length = vec1.size();
    for(int i=0;i<length;i++)
    {
       cout<<vec1[i];
    }
    cout<<endl<<endl;
